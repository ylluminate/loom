#!/usr/bin/env python3
"""
Render a TrueType/OpenType font as an 8x16 bitmap font for bare-metal OS.

Generates an Erlang module containing pre-rendered glyphs for ASCII 32-126.
Each glyph is 16 bytes (8 pixels wide, 16 rows, MSB = leftmost pixel).
"""

import argparse
import sys
from pathlib import Path
from PIL import Image, ImageFont, ImageDraw


def render_glyph(char: str, font: ImageFont.FreeTypeFont, size: int = 16) -> list[int]:
    """
    Render a single character as an 8x16 bitmap.

    Returns a list of 16 bytes, one per row, MSB = leftmost pixel.
    """
    # Create 8x16 grayscale image (black background)
    img = Image.new('L', (8, 16), 0)
    draw = ImageDraw.Draw(img)

    # Get glyph bounding box for centering
    try:
        bbox = font.getbbox(char)
    except AttributeError:
        # Fallback for older Pillow versions
        bbox = draw.textbbox((0, 0), char, font=font)

    if char == ' ':
        # Space should be all zeros
        return [0] * 16

    # Calculate offset to center glyph in 8x16 cell
    # Horizontal centering
    glyph_width = bbox[2] - bbox[0]
    x_offset = (8 - glyph_width) // 2 - bbox[0]

    # Vertical alignment - use a consistent baseline
    # Place text so baseline is at row 13 (3 rows for descenders)
    # For most fonts, this gives good alignment
    y_offset = 13 - bbox[3]

    # Draw the character
    draw.text((x_offset, y_offset), char, font=font, fill=255)

    # Convert to bitmap bytes
    glyph_bytes = []
    for row in range(16):
        byte = 0
        for col in range(8):
            # Threshold: >128 = foreground (1), <=128 = background (0)
            if img.getpixel((col, row)) > 128:
                byte |= (0x80 >> col)
        glyph_bytes.append(byte)

    return glyph_bytes


def find_best_font_size(font_path: str, test_chars: str = "AaBbWwMm@") -> int:
    """
    Try different font sizes to find one that fits well in 8x16.

    Returns the recommended font size.
    """
    print(f"Testing font sizes for: {test_chars}")
    best_size = 12
    best_score = float('inf')

    for size in range(10, 17):
        font = ImageFont.truetype(font_path, size)

        # Test how well typical chars fit
        total_overflow = 0
        for char in test_chars:
            bbox = font.getbbox(char)
            width = bbox[2] - bbox[0]
            height = bbox[3] - bbox[1]

            # Penalize overflow beyond 8x16
            width_overflow = max(0, width - 8)
            height_overflow = max(0, height - 16)

            # Also penalize being too small (want to use the space)
            width_underuse = max(0, 5 - width) * 0.5

            total_overflow += width_overflow + height_overflow + width_underuse

        avg_overflow = total_overflow / len(test_chars)
        print(f"  Size {size:2d}: avg_overflow={avg_overflow:.2f}")

        if avg_overflow < best_score:
            best_score = avg_overflow
            best_size = size

    print(f"→ Recommended size: {best_size}")
    return best_size


def generate_erlang_module(font_path: str, font_size: int, output_path: str):
    """
    Generate an Erlang module with pre-rendered bitmap data.
    """
    font = ImageFont.truetype(font_path, font_size)

    print(f"Rendering {font_path} at size {font_size}...")

    # Render all ASCII printable characters (32-126)
    all_bytes = []
    for char_code in range(32, 127):
        char = chr(char_code)
        glyph_bytes = render_glyph(char, font)
        all_bytes.extend(glyph_bytes)

        if char_code % 10 == 0:
            print(f"  Rendered {char_code - 31}/95 characters...")

    print(f"Total bytes: {len(all_bytes)} (expected 1520)")

    # Format as Erlang binary (like VGA font format)
    hex_lines = []
    for char_code in range(32, 127):
        # Add comment before the glyph data
        char_repr = chr(char_code) if 33 <= char_code <= 126 else f' (space)'
        if char_code == 32:
            hex_lines.append(f"    %% {char_code} - Space")
        else:
            hex_lines.append(f"    %% {char_code} - {char_repr}")

        # Get the 16 bytes for this glyph
        idx = (char_code - 32) * 16
        chunk = all_bytes[idx:idx+16]
        hex_str = ','.join(f'16#{b:02X}' for b in chunk)

        # Add trailing comma except for last glyph
        if char_code < 126:
            hex_lines.append(f"    {hex_str},")
        else:
            hex_lines.append(f"    {hex_str}")

    # Generate module
    font_name = Path(font_path).stem.lower().replace('-', '_')
    module_content = f'''%% Generated by render_font_bitmap.py
%% Font: {Path(font_path).name}
%% Size: {font_size}pt
%% Format: 8x16 bitmap, 95 ASCII characters (32-126)
%% Total: 1520 bytes (95 chars × 16 bytes/char)

-module(vbeam_font_monaspice).
-export([glyph/1, font_binary/0, char_width/0, char_height/0]).

%% Get the bitmap for a single character (16 bytes = 8x16 pixels)
-spec glyph(char()) -> binary().
glyph(Char) when Char >= 32, Char =< 126 ->
    Offset = (Char - 32) * 16,
    binary:part(font_data(), Offset, 16);
glyph(_) ->
    glyph($?).  %% Fallback to '?' for unknown chars

%% Get the complete font binary
-spec font_binary() -> binary().
font_binary() -> font_data().

%% Font dimensions
-spec char_width() -> pos_integer().
char_width() -> 8.

-spec char_height() -> pos_integer().
char_height() -> 16.

%% Internal: the bitmap data
-spec font_data() -> binary().
font_data() ->
    <<
{chr(10).join(hex_lines)}
    >>.
'''

    # Write to file
    output_file = Path(output_path)
    output_file.parent.mkdir(parents=True, exist_ok=True)
    output_file.write_text(module_content)

    print(f"✓ Generated {output_path}")
    print(f"  Module: vbeam_font_monaspice")
    print(f"  Characters: 95 (ASCII 32-126)")
    print(f"  Size: 8x16 pixels per glyph")
    print(f"  Total: {len(all_bytes)} bytes")


def generate_preview(font_path: str, font_size: int, output_path: str):
    """
    Generate a preview image showing all rendered glyphs.
    """
    font = ImageFont.truetype(font_path, font_size)

    # Grid layout: 16 chars per row, 6 rows (32-126 = 95 chars)
    chars_per_row = 16
    rows = 6
    cell_width, cell_height = 8, 16
    margin = 2

    img_width = chars_per_row * (cell_width + margin)
    img_height = rows * (cell_height + margin)

    # Create preview image (white background)
    preview = Image.new('RGB', (img_width, img_height), (255, 255, 255))

    for char_code in range(32, 127):
        char = chr(char_code)
        glyph_bytes = render_glyph(char, font)

        # Calculate position in grid
        idx = char_code - 32
        row = idx // chars_per_row
        col = idx % chars_per_row

        x_start = col * (cell_width + margin)
        y_start = row * (cell_height + margin)

        # Draw the bitmap
        for y in range(16):
            byte = glyph_bytes[y]
            for x in range(8):
                if byte & (0x80 >> x):
                    preview.putpixel((x_start + x, y_start + y), (0, 0, 0))

    preview.save(output_path)
    print(f"✓ Generated preview: {output_path}")


def main():
    parser = argparse.ArgumentParser(description='Render TrueType font as 8x16 bitmap for Erlang')
    parser.add_argument('font_path', help='Path to .ttf or .otf font file')
    parser.add_argument('-o', '--output', default='os/nucleus/vbeam_font_monaspice.erl',
                        help='Output Erlang module path')
    parser.add_argument('-s', '--size', type=int, default=0,
                        help='Font size (0 = auto-detect best fit)')
    parser.add_argument('--preview', help='Generate preview PNG')
    parser.add_argument('--find-size', action='store_true',
                        help='Find best font size and exit')

    args = parser.parse_args()

    font_path = Path(args.font_path)
    if not font_path.exists():
        print(f"Error: Font file not found: {font_path}", file=sys.stderr)
        return 1

    # Find best size if requested or auto
    if args.find_size or args.size == 0:
        best_size = find_best_font_size(str(font_path))
        if args.find_size:
            return 0
        font_size = best_size
    else:
        font_size = args.size

    # Generate Erlang module
    generate_erlang_module(str(font_path), font_size, args.output)

    # Generate preview if requested
    if args.preview:
        generate_preview(str(font_path), font_size, args.preview)

    return 0


if __name__ == '__main__':
    sys.exit(main())
