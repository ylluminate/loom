CRITICAL|arch/x86_64/vbeam_native_lower_x86_64.erl:384|ret pops callee-saved registers before reclaiming FrameSize, so functions with spills restore garbage and violate callee-save ABI|Deallocate local frame first (or restore saved regs via rbp-relative loads), then restore callee-saved regs, then pop rbp and ret
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:41|Stack alignment math is wrong for odd callee-saved counts, leaving rsp 8-byte misaligned at call sites and violating SysV AMD64 ABI|Choose frame padding so (8*callee_saved_count + frame_size) mod 16 == 0 before any call
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:1396|Cycle-breaking for argument moves uses one temp for all breakpoints and does not rotate values, corrupting swaps like rdi<->rsi|Implement per-cycle rotation (save one source, apply ordered moves, restore final destination) instead of global save/restore lists
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:1410|Stack argument loads for method_call ignore callee-saved spill displacement, so spilled arguments are read from wrong slots|Thread spill-base context into emit_move_x86 and use the same slot offset formula as other stack loads
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:1063|int_to_str clobbers callee-saved r13 without saving/restoring it, corrupting live values allocated there|Push/pop r13 in this pseudo-op or reserve r13 in scratch exclusion when conversion pseudo-ops are present
CRITICAL|arch/ir/vbeam_native_regalloc.erl:490|Spilled virtual registers are rewritten directly to {stack,Slot} operands with no spill code insertion, leaving many ops unlowerable or semantically wrong|Insert explicit reload/store code around spilled uses and defs (or run a dedicated spill-materialization pass) before lowering
HIGH|arch/ir/vbeam_native_regalloc.erl:471|Only the first 6 x86_64 or 8 arm64 parameters are assigned ABI locations, so higher-arity params are never loaded from caller stack|Add stack-parameter mappings and loads for parameters beyond register argument limits
HIGH|arch/arm64/vbeam_native_lower_arm64.erl:1465|Cycle-breaking for argument moves restores First from temp without applying the closing source move, corrupting register permutations|Emit true cycle-rotation order and use temp only for one saved edge per cycle
HIGH|arch/arm64/vbeam_native_lower_arm64.erl:1325|Unhandled instructions are silently dropped (returns []), causing silent control-flow and data-flow corruption|Fail codegen on unknown opcodes (raise error or emit trap bytes) instead of eliding instructions
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:1328|method_call silently drops arguments beyond six registers instead of passing overflow args on stack|Implement SysV overflow-argument stack emission with correct call-site stack alignment
HIGH|arch/arm64/vbeam_native_lower_arm64.erl:1393|method_call silently drops arguments beyond x0..x7 instead of passing overflow args on stack|Implement AAPCS64 overflow-argument stack passing while preserving 16-byte sp alignment
HIGH|arch/ir/vbeam_native_alloc.erl:100|x86_64 allocator init does not validate mmap result and can install negative errno in heap pointer r15|Check rax for syscall failure before assigning r15 and trap or exit on error
HIGH|arch/ir/vbeam_native_alloc.erl:114|Bump allocator advances heap pointer without any heap-end check, enabling out-of-bounds writes|Track heap end and compare new pointer on every allocation (emit_alloc and emit_alloc_reg), trapping or growing heap on overflow
MEDIUM|arch/ir/vbeam_native_alloc.erl:81|ARM64 mmap failure path hardcodes Linux sys_exit=93 even for macho, so macOS error handling issues the wrong syscall|Select exit syscall number by format (x16/1 for macOS, x8/93 for Linux)