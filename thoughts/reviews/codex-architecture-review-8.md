Baseline: `make compile && make check && make test` passed.

CRITICAL|arch/x86_64/vbeam_native_lower_x86_64.erl:108|Spill slot addressing subtracts `length(UsedCalleeSaved)*8` while callee-saved registers are pushed after `sub rsp, FrameSize` (`:54-58`), but `FrameSize` does not include that area; spilled values can overwrite saved callee registers and corrupt return state.|Use a single frame layout: either push callee-saved before allocating spills and address spills as `rbp-(slot+1)*8`, or include callee-save space in frame size and stop extra push/pop-based placement.
CRITICAL|arch/x86_64/vbeam_native_lower_x86_64.erl:648|`array_append` computes copy bound in bytes (`len * ElemSize`) but copies/stores 8-byte words and advances by 8 (`:656-660`); for `ElemSize != 8` this causes out-of-bounds reads/writes and heap corruption.|Emit copy/load/store width based on `ElemSize` (or byte-copy loop) and increment by the actual copied width.
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:50|Callee-saved registers are pushed without compensating alignment; odd push counts leave `%rsp` misaligned at call sites (`:301`, `:306`, `:927`), violating SysV AMD64 16-byte stack alignment requirements.|Add 8-byte padding when callee-save push count is odd, or save callee-saved regs into fixed frame slots instead of additional pushes.
HIGH|arch/ir/vbeam_native_regalloc.erl:463|x86 scratch exclusion for pseudo-ops reserves only `r10/r11`, but lowered pseudo-ops clobber additional registers (`rax/rcx/rdx/rsi/rdi/r8/r9` etc.); allocator can keep live values in clobbered regs, causing silent register corruption.|Model full per-pseudo-op clobber sets and exclude all clobbered registers (or lower pseudo-ops before RA and represent clobbers as defs).
HIGH|arch/arm64/vbeam_native_lower_arm64.erl:49|Large-frame path uses single `SUB/ADD (imm12)` with `FrameSize-16` (`:49`, `:64`); frames above imm12 range cannot be encoded and will fail codegen/emit invalid sequences.|For large frames, materialize size in a temp register and use register add/sub, or split into multiple encodable immediates.
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:1285|`emit_move_x86` loads `{stack, Slot}` using `-(Slot+1)*8`, inconsistent with main spill-slot addressing (`:108/:113`), so method-call argument marshalling can read wrong stack slots under spills/callee-saves.|Centralize stack-slot address computation and use the same final frame-layout formula everywhere.
HIGH|arch/arm64/vbeam_native_lower_arm64.erl:1361|`emit_move_arm64` uses `x29 + 16 + Slot*8` for stack args, but normal stack-slot accesses include callee-saved area (`:105/:111`); spilled arguments can be loaded from wrong offsets.|Thread callee-saved count into arg-move lowering (or share a single stack-slot offset helper).
HIGH|kernel/boot/vbeam_boot_sequence.erl:88|Boot path unmasks all PIC IRQ lines before non-timer handlers exist; vectors 33+ route to generic halt stub, so common device IRQs can halt the CPU.|Mask all IRQs except timer until handlers are installed, or provide default ACK-and-return handlers for unbound IRQ vectors.
MEDIUM|arch/x86_64/vbeam_native_lower_x86_64.erl:319|`{push, {imm, ...}}` lowers to empty code, silently dropping stack mutation and breaking frame/control-flow assumptions when this IR appears.|Encode `push imm32` (`0x68 imm32`) or lower via `mov tmp, imm` + `push tmp`.
