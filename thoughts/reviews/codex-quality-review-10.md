HIGH|kernel/io/vbeam_io_server.erl:111|`max_log_size` is accepted from options without validation; `0` or negative values cause `lists:droplast([])` crash on first log write|Validate `max_log_size` in `init/1` as integer `> 0` (or clamp to default) before storing state
HIGH|kernel/io/vbeam_io_server.erl:133|`get_log` always materializes the full log into one binary, so large accumulated entries can trigger allocation spikes and OOM|Enforce a total log-byte budget and return bounded/sliced log data instead of always flattening full history
HIGH|kernel/io/vbeam_io_server.erl:355|Log retention is bounded by entry count only; a single huge `String` entry can consume unbounded memory and persist in state|Cap per-entry byte size and maintain a byte-based ring buffer limit (drop/truncate oversized writes)
HIGH|kernel/io/vbeam_irq_bridge.erl:261|`unregister_handler` has no caller authorization, so any process can remove another IRQ handler (DoS/hijack)|Require caller ownership/capability checks before unregistering and reject unauthorized requests
HIGH|kernel/io/vbeam_irq_bridge.erl:126|Any process can register handlers for IRQs without capability checks, allowing interrupt capture if registration is raced|Gate registration behind trusted caller checks (owner token/capability/supervisor-only API)
MEDIUM|kernel/io/vbeam_irq_bridge.erl:126|IRQ number is only checked as non-negative and has no upper bound, enabling unbounded handler-map growth|Validate IRQ range (for example `0..255` or platform max) before registration
HIGH|kernel/sched/vbeam_scheduler.erl:286|`max_processes` defaults to `infinity`, so callers can spawn unbounded processes/heaps and exhaust memory|Default to a finite hard limit and require explicit privileged override for higher caps
HIGH|kernel/sched/vbeam_scheduler.erl:330|`kill_process` has no authorization and can terminate critical processes (including PID 0 idle process), enabling scheduler DoS|Enforce caller permissions and block kills of reserved/system PIDs
HIGH|kernel/sched/vbeam_scheduler.erl:370|Mailbox protection is count-only; oversized message terms can still exhaust memory despite entry limit|Track/cap mailbox bytes and reject messages above a per-message size limit
HIGH|vm/parser/vbeam_beam_parser.erl:13|`parse_file/1` reads entire input file with no size cap, enabling file-size memory DoS|Check file size before read (or stream parse) and reject inputs above a configured maximum
HIGH|vm/parser/vbeam_beam_parser.erl:265|Final `zlib:inflate(Z, <<>>)` flush path does not enforce `MaxSize`, allowing decompression output to exceed configured limit|Apply the same output-size check on flush output before returning `{ok, Final}`
MEDIUM|vm/parser/vbeam_beam_parser.erl:278|Chunk decompression repeatedly rebuilds full accumulator via `iolist_to_binary([Acc | Decompressed])`, creating O(n^2) copy overhead|Accumulate chunks as iolist with running byte count and flatten once at end
HIGH|vm/parser/vbeam_beam_standalone.erl:30|`parse_file/1` reads entire input file with no size cap, enabling file-size memory DoS|Check file size before read (or stream parse) and reject oversized BEAM files
HIGH|vm/parser/vbeam_beam_standalone.erl:255|Final inflate flush path skips `MaxSize` enforcement, so output can exceed the decompression cap|Validate flush output size against `MaxSize` before accepting it
MEDIUM|vm/parser/vbeam_beam_standalone.erl:268|Decompression loop performs repeated full-buffer copies (`iolist_to_binary` per chunk), enabling CPU/memory amplification|Use iolist accumulation plus incremental size accounting, then flatten once
HIGH|vm/interp/vbeam_beam_interp_v2.erl:122|Interpreter loop has no instruction/reduction budget, so crafted bytecode can run forever and pin CPU|Add a step/reduction counter and abort with timeout/error when budget is exceeded
HIGH|vm/interp/vbeam_beam_interp_v2.erl:245|`allocate`/`allocate_zero` trust `StackNeed` from bytecode and can allocate arbitrarily large lists (`lists:duplicate`)|Validate frame size against a strict maximum before allocation
HIGH|vm/interp/vbeam_beam_interp_v2.erl:484|Sparse Y-register writes can extend Y with `lists:duplicate(N-Len, ...)`, enabling unbounded memory growth from large indexes|Reject out-of-range Y indexes or cap maximum register index/frame growth
HIGH|vm/interp/vbeam_beam_interp.erl:144|Interpreter loop has no instruction budget, enabling infinite-loop CPU DoS from malicious bytecode|Enforce a maximum instruction/reduction count per execution
HIGH|vm/interp/vbeam_beam_interp.erl:203|`allocate` uses unchecked `StackNeed`, allowing unbounded stack-frame allocation|Validate `StackNeed` against a hard maximum and fail fast on oversized frames
MEDIUM|vm/interp/vbeam_beam_interp.erl:211|`deallocate` calls `lists:nthtail/2` without bounds checks, so malformed input can crash interpreter state|Check `N >= 0` and `N =< length(Y)` before deallocating
MEDIUM|vm/interp/vbeam_beam_interp.erl:437|`set_register` for Y uses `lists:nthtail(N+1, Y)` without bounds validation, causing crashes on malformed indexes|Add explicit bounds checks and return structured error on invalid Y index
HIGH|vm/interp/vbeam_beam_interp_bare.erl:235|Main execution loop has no instruction budget, enabling unbounded CPU consumption|Add an execution step budget with configurable limit/timeout
HIGH|vm/interp/vbeam_beam_interp_bare.erl:782|`allocate_stack/2` accepts unchecked `N`; large values cause OOM and negative values can hit `duplicate_bare` function_clause|Validate `N` as non-negative and below a strict maximum before allocation
HIGH|vm/interp/vbeam_beam_interp_bare.erl:532|BIF argument collection uses `seq_bare(0, Arity-1)` from import-derived arity, enabling huge list allocation DoS|Validate/cap arity before building argument index lists
HIGH|compat/elf/vbeam_elf_loader.erl:245|`load/2` reads full ELF file with no size guard, allowing file-size memory DoS|Reject files above a configured max size before `file:read_file/1`
HIGH|compat/elf/vbeam_elf_loader.erl:436|`NumSyms` is derived directly from section size with no upper cap, enabling massive symbol-list allocation|Add a maximum symbol count threshold and reject oversized tables
HIGH|compat/elf/vbeam_elf_loader.erl:492|`NumRelas` is derived directly from relocation section size with no upper cap, enabling massive relocation-list allocation|Add a maximum relocation count threshold and reject oversized relocation sections
HIGH|compat/kpi/vbeam_linuxkpi.erl:50|Timer ETS table is created `public`, letting arbitrary processes mutate/delete timer refs|Use `protected`/`private` and funnel writes through a single owner process
HIGH|compat/kpi/vbeam_linuxkpi.erl:444|Timer reference table has no cardinality or expiry controls, enabling unbounded ETS growth|Add max-table-size enforcement and periodic cleanup/TTL for stale timer refs
HIGH|compat/kpi/vbeam_linuxkpi.erl:442|Timer refs are keyed only by `Timer`, so different processes can overwrite/cancel each otherâ€™s timers|Namespace keys by owner (`{Pid, Timer}`) and enforce owner-only delete/update
HIGH|arch/ir/vbeam_native_alloc.erl:100|x86_64 allocator init stores raw `mmap` return into heap register without checking syscall failure|Check `rax` for negative error returns and fail/exit before using it as heap base
CRITICAL|arch/ir/vbeam_native_alloc.erl:109|Bump allocator emits pointer increments with no heap-end bounds checks, allowing generated code to overrun heap memory|Track heap end and emit runtime bounds checks before every pointer advance (trap/fail on overflow)
HIGH|arch/link/vbeam_native.erl:264|Unresolved symbols are auto-stubbed to return `0` (fail-open), masking missing logic and potentially bypassing security-critical paths|Fail closed on unresolved symbols by default; allow stubbing only via explicit unsafe debug flag
MEDIUM|arch/link/vbeam_native_link.erl:265|ARM64 patchers pattern-match instruction words without verifying `Offset+4 <= byte_size(Bin)`, causing crashes on malformed relocation offsets|Add explicit bounds checks before patch pattern matches and return structured relocation errors
MEDIUM|arch/formats/vbeam_native_elf.erl:102|Entry offset is not validated against code size, so emitted entrypoint can point outside `.text`|Validate `EntryOffset < byte_size(Code)` and reject invalid entry offsets
MEDIUM|arch/formats/vbeam_native_pe.erl:122|Entry RVA is computed from unchecked `EntryOffset`, allowing out-of-section entrypoints|Validate `EntryOffset` bounds before computing `EntryRVA`
MEDIUM|arch/formats/vbeam_native_macho.erl:115|`LC_MAIN` entry offset is computed from unchecked `EntryOffset`, allowing invalid startup address|Validate `EntryOffset` against code size before building `LC_MAIN`