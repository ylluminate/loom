Baseline: `make compile && make check && make test` passed.

CRITICAL|arch/ir/vbeam_native_regalloc.erl:364|When callee-saved registers are exhausted, call-spanning parameters are intentionally left in caller-saved registers ("value will be wrong across calls"), causing deterministic corruption after nested calls|Spill those intervals or insert save/restore around calls; never keep known-invalid assignments
CRITICAL|arch/x86_64/vbeam_native_lower_x86_64.erl:107|Spill slots use `[rbp-(slot+1)*8]` while callee-saved registers are pushed after frame setup, so spill writes can alias saved-register slots and corrupt epilogue restores|Use one fixed frame layout that reserves callee-save space, or offset spills by `8*length(UsedCalleeSaved)`
CRITICAL|arch/arm64/vbeam_native_lower_arm64.erl:47|Large-frame prologue sets `x29` before subtracting `FrameSize-16`, so later `[x29,#off]` accesses target memory outside the allocated frame|Set `x29` after full stack allocation (or switch to SP-relative accesses)
CRITICAL|arch/arm64/vbeam_native_lower_arm64.erl:102|AAPCS64 frame layout is inconsistent: spill slots start at `x29+16`, which is also used for saved callee-saved registers, causing overlap/corruption|Start spill area after callee-save area (`16 + 8*NumCalleeSaved`) and share one canonical layout function
HIGH|arch/x86_64/vbeam_native_lower_x86_64.erl:1235|Argument register setup is emitted sequentially without parallel-move handling, so register cycles clobber arguments (e.g. swap patterns)|Implement cycle-safe parallel move with temp register/spill slot
HIGH|arch/arm64/vbeam_native_lower_arm64.erl:1308|AAPCS64 argument setup has the same sequential-move clobber bug for overlapping x0-x7 moves|Use the same cycle-safe parallel move algorithm on ARM64
HIGH|kernel/io/vbeam_irq_bridge.erl:182|ISR code clobbers `r11`/`r8` without saving/restoring, violating interrupt-context register preservation assumptions|Save/restore all clobbered GPRs (or constrain stub to preserved regs only) before `iretq`
HIGH|kernel/io/vbeam_irq_bridge.erl:195|ISR reads IRQ number from `[rsp+24]` based on an assumed stub frame that is not guaranteed by current timer/IDT path|Define one ISR entry contract (push vector/error consistently) and read IRQ from that verified frame
HIGH|kernel/boot/vbeam_boot_sequence.erl:68|Boot path halts immediately after GDT/IDT/CR3/stack setup, so PIC/PIT init, `sti`, and scheduler/ISR integration never execute|After setup, initialize interrupt controller/timer, enable interrupts, and jump to kernel entry instead of halting
HIGH|compat/elf/vbeam_elf_loader.erl:218|Section address map is keyed by full section maps, but relocated sections are mutated (`Section#{data:=...}`), so later lookups miss and default to address 0, breaking placement/padding|Key section addresses by stable section index/name, not mutable map terms
HIGH|vm/interp/vbeam_beam_interp_bare.erl:309|`call_last` ignores dealloc operand and tail-call path clears entire `y` stack, dropping caller frames and corrupting return behavior|Apply requested deallocation for current frame only and preserve outer frames on tail call
MEDIUM|vm/interp/vbeam_beam_interp_v2.erl:415|Valid BEAM opcodes like `call_last`/`call_ext_last` are unhandled and fall into unknown-instruction failure|Add explicit handlers implementing proper dealloc + tail-call semantics
MEDIUM|vm/interp/vbeam_beam_interp.erl:299|Opcode map diverges from BEAM opcode table (e.g. 59/78), so decoder PC advancement/state machine desynchronizes on real bytecode|Use shared `vbeam_beam_standalone` decoder or synchronize opcode/arity table to current BEAM spec
MEDIUM|arch/ir/vbeam_native_alloc.erl:94|Bump allocator advances heap pointer without bounds checks against mapped heap size, allowing silent heap overrun|Track heap end and guard each allocation (`heap_ptr + size <= heap_end`) with trap/grow path
