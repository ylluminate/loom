Baseline: `make compile && make check && make test` passed (`exit 0`).

HIGH|compat/elf/vbeam_elf_loader.erl:218|`SectionAddrs` is keyed by full section maps, but relocated sections are mutated (`Section#{data := ...}`), so lookups default to `0` and section layout offsets become incorrect for relocated sections.|Key `SectionAddrs` by stable identifiers (section index or `{name,idx}`), and use that key consistently before/after relocation.
HIGH|compat/elf/vbeam_elf_loader.erl:406|`EntSize` from ELF is used as a divisor without validation (`div EntSize`), and parsing still uses fixed strides (`?SYM_SIZE`/`?RELA_SIZE`), allowing divide-by-zero and malformed-table misparse/DoS.|Validate `EntSize > 0` and `EntSize =:= ?SYM_SIZE` (and `?RELA_SIZE` for relocs) before parsing; reject mismatches with `{error, invalid_entsize}`.
HIGH|arch/link/vbeam_native_link.erl:251|`patch_adrp/3` masks `PageDelta` into imm fields without signed 21-bit range validation, causing silent truncation and wrong ARM64 target pages.|Before masking, enforce `PageDelta >= -(1 bsl 20)` and `PageDelta < (1 bsl 20)`; return explicit overflow error if out of range.
HIGH|vm/parser/vbeam_beam_parser.erl:142|`LitT` decompression has no hard cap or validation against `UncompressedSize`, enabling decompression memory-exhaustion input.|Enforce max decompressed size, verify actual size matches declared size, and fail early on oversized literals.
HIGH|vm/parser/vbeam_beam_standalone.erl:163|`LitT` decompression path is also unbounded and can inflate attacker-controlled compressed data into large allocations.|Add strict decompressed-size limits and declared-size checks before accepting/decompressing literals.

MEDIUM|compat/elf/vbeam_elf_loader.erl:350|Multiple `lists:nth/2` uses (`350/402/450/530/626`) are unchecked; malformed indexes crash with `badarg` instead of structured loader errors.|Validate each index (`>=0` and `< length(List)`) before access and return typed `{error, invalid_index,...}`.
MEDIUM|vm/parser/vbeam_beam_standalone.erl:288|`binary_to_term/2` in literal parsing is not caught; malformed literal entries can crash parse instead of returning `{error,...}`.|Wrap in `try/catch` and propagate parse errors as tagged error tuples.
MEDIUM|vm/parser/vbeam_beam_standalone.erl:461|Compact-term large integer decode treats `LenCode=7` as fixed `Len=9`, but BEAM uses recursive length encoding there; operands can decode incorrectly.|Implement the recursive length form for `LenCode=7` (matching BEAM encoding) instead of forced 9-byte decode.
MEDIUM|vm/interp/vbeam_beam_interp.erl:314|Truncated integer/arg decode silently falls back to `0`/`{x,0}`, corrupting control/data flow instead of failing fast.|Return explicit decode errors on truncation and stop interpretation.
MEDIUM|vm/interp/vbeam_beam_interp.erl:179|Missing label lookup defaults to PC `0`, which can silently jump to wrong code and hide corruption.|Use `maps:find/2`; return `{error,{label_not_found,Label}}` when absent.
MEDIUM|vm/interp/vbeam_beam_interp_v2.erl:255|`lists:nthtail(N, Y)` is called without bounds validation; malformed `deallocate` operands can raise and crash.|Validate `N >= 0` and `N =< length(Y)` before `nthtail`; return interpreter error on invalid stack deallocate.
MEDIUM|vm/interp/vbeam_beam_interp_v2.erl:457|Y-register read checks only `N < length(Y)`; negative `N` passes and `lists:nth(N+1, Y)` crashes.|Require `is_integer(N) andalso N >= 0 andalso N < length(Y)` before indexing.
MEDIUM|kernel/sched/vbeam_scheduler.erl:146|PIT divisor is computed and byte-split without range validation; out-of-range frequencies silently program invalid timer values (including divisor `0`).|Validate divisor `>=1` and `=<65535` (or validate `FreqHz` bounds) and return an error for unsupported frequencies.

LOW|arch/x86_64/vbeam_native_lower_x86_64.erl:1256|`ImmByte band 16#FF` silently truncates immediate byte values.|Validate `ImmByte` range (`0..255`) and reject invalid inputs instead of masking.
LOW|kernel/arch/vbeam_gdt_idt.erl:579|`encode_inc_mem64/2` lacks x86-64 base-register special-case handling for `rbp/r13` and `rsp/r12` at zero offset, so emitted ModR/M can be invalid in those cases.|Use the same addressing helper logic as `encode_mem_op/4` (emit disp8=0 for `rbp/r13`, SIB for `rsp/r12`).
