# Loom OS

**An operating system where BEAM *is* the kernel.**

V programs compile to BEAM bytecode. BEAM runs on bare metal. Drivers are supervised Erlang processes that crash and restart without bringing down the system. The compiler emits native x86_64 machine code, closing the self-hosting loop.

---

## What is this?

Loom OS is a research operating system built on three insights:

1. **BEAM already is a microkernel.** It provides process isolation, preemptive scheduling, message-passing IPC, and fault supervision. Instead of writing a microkernel and running BEAM on top, we run BEAM directly on hardware.

2. **V is a better systems language than C.** Clean syntax, no undefined behavior, immutable by default. V compiles to BEAM bytecode (for the VM path) and to native x86_64 (for the bare-metal path).

3. **Fault tolerance should be the default, not an afterthought.** Every driver, service, and application is a supervised BEAM process. A crash is an event, not a catastrophe.

## Project Structure

```
loom/
├── src/
│   ├── nucleus/       UEFI boot (PE32+, GOP framebuffer, VGA fonts)
│   ├── beam_vm/       BEAM interpreter + standalone parser (no OTP deps)
│   ├── kernel/        GDT/IDT, paging, heap, scheduler, I/O, IRQ, JIT
│   ├── compat/        Linux syscalls (~450), ELF loader, LinuxKPI shims
│   └── native/        x86_64 + ARM64 backends, IR, regalloc, PE/ELF/Mach-O
├── tests/native/      V test programs for native compilation
├── docs/              Architecture docs, boot sequence, syscall tables
├── scripts/           Build, test, and QEMU scripts
├── meta/              Hackathon submission materials
├── assets/            Images and font previews
└── thoughts/          Architecture sketches and design notes
```

## The Pipeline

```
V Source (.v)
     |
     v
V-on-BEAM Compiler (vbeam — separate repo)
     |
     +---> BEAM bytecode (.beam)  ---> BEAM VM ---> output
     |
     +---> Native x86_64 binary   ---> bare metal ---> output
```

## Boot from Nothing

Loom OS boots on real UEFI hardware:

```
UEFI firmware
  -> nucleus.efi (5KB PE32+ binary, generated by Erlang)
    -> Serial console init (COM1, 115200 baud)
    -> GOP framebuffer init (800x600x32bpp)
    -> Boot splash: loom grid + "LOOM OS v0.2.0"
    -> V native code executes: "Hello from V on BEAM!"
```

The entire boot binary is generated byte-by-byte by Erlang. No assembler, no linker, no external toolchain.

## Fault Tolerance (The Killer Feature)

```
Linux:     Driver crashes -> kernel panic -> reboot -> minutes of downtime
Loom OS:   Driver crashes -> supervisor restarts it -> <1ms -> users never notice
```

Every component is a supervised process:
```
                loom_root_sup
               /      |       \
          hal_sup   beam_sup   app_sup
         /  |  \      |  \      |  \
      serial fb timer code proc vfs net
```

## Hot Code Reload

Update a running driver without stopping the system. Same PID. Same state. New code. No restart.

## Component Status

| Component | Status | Location |
|-----------|--------|----------|
| UEFI boot nucleus | 5KB .efi, boots in QEMU | `src/nucleus/` |
| Boot splash | GOP framebuffer, VGA fonts, loom grid | `src/nucleus/` |
| BEAM interpreter | 30+ opcodes, runs V hello world | `src/beam_vm/` |
| Standalone parser | No OTP deps, bare-metal ready | `src/beam_vm/` |
| Kernel: scheduler | Preemptive, priority-based | `src/kernel/` |
| Kernel: memory | Page allocator, paging, heap | `src/kernel/` |
| Kernel: I/O + IRQ | Serial, framebuffer, interrupt bridge | `src/kernel/` |
| BEAM-to-native JIT | BEAM bytecode -> x86_64 machine code | `src/kernel/` |
| Linux syscall layer | ~450 syscalls mapped | `src/compat/` |
| ELF .ko loader | Full ELF64 parsing, x86_64 relocations | `src/compat/` |
| LinuxKPI shims | 66 Linux kernel API stubs | `src/compat/` |
| Native x86_64 | 53 privileged instructions | `src/native/` |
| Native ARM64 | 68/68 examples compile | `src/native/` |
| IR + regalloc | Full pipeline, data type IR | `src/native/` |
| PE/ELF/Mach-O | All three object formats | `src/native/` |

## Build & Run

```bash
# Prerequisites: Erlang/OTP 26+

# Build the UEFI nucleus
make nucleus

# Test in QEMU (requires qemu-system-x86_64 + OVMF)
make qemu-test

# Run kernel tests
make test-kernel

# Compile all Erlang source modules
make compile
```

## Relationship to vbeam

Loom OS was developed within the [vbeam](https://github.com/ylluminate/vbeam) project and has been separated into its own repository for clarity. The V-to-BEAM compiler lives in vbeam; the OS kernel and native backends live here.

## Built with Claude Opus 4.6

This entire system was designed and implemented in collaboration with Claude Opus 4.6, which:

- Wrote x86_64 machine code byte-by-byte for the UEFI bootloader
- Implemented a BEAM bytecode interpreter from scratch
- Designed the QNX-like supervisor tree architecture
- Fixed PE32+ emitter bugs by understanding the PE spec
- Generated VGA bitmap font rendering in raw machine code
- Parallelized implementation across 7+ simultaneous Sonnet workers
- Maintained project continuity across 30+ sessions via structured handoff documents

## License

Open source. MIT.
