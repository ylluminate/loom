# Loom OS

**An operating system where BEAM *is* the kernel.**

V programs compile to BEAM bytecode. BEAM runs on bare metal. Drivers are supervised Erlang processes that crash and restart without bringing down the system. The compiler emits native x86_64 machine code, closing the self-hosting loop.

---

## What is this?

Loom OS is a research operating system built on three insights:

1. **BEAM already is a microkernel.** It provides process isolation, preemptive scheduling, message-passing IPC, and fault supervision. Instead of writing a microkernel and running BEAM on top, we run BEAM directly on hardware.

2. **V is a better systems language than C.** Clean syntax, no undefined behavior, immutable by default. V compiles to BEAM bytecode (for the VM path) and to native x86_64 (for the bare-metal path).

3. **Fault tolerance should be the default, not an afterthought.** Every driver, service, and application is a supervised BEAM process. A crash is an event, not a catastrophe.

## Project Structure

```
loom/
├── boot/                 UEFI boot (PE32+, GOP framebuffer, VGA fonts)
│   ├── fonts/            VGA 8x16 + MonaSpice bitmap fonts
│   └── esp/              EFI System Partition layout
├── kernel/               Core kernel subsystems
│   ├── boot/             Boot sequence orchestration (GDT→IDT→paging→stack→run)
│   ├── mm/               Memory: page allocator, 4-level paging, BEAM heap
│   ├── sched/            Preemptive round-robin scheduler (timer IRQ)
│   ├── io/               Serial/framebuffer I/O, hardware IRQ→BEAM bridge
│   └── arch/             x86_64 GDT and IDT setup
├── vm/                   BEAM virtual machine
│   ├── interp/           Interpreters: v1 (minimal), v2 (beam_disasm), bare (no OTP)
│   ├── parser/           BEAM file parsers: standard (IFF) + standalone (zero OTP deps)
│   └── jit/              BEAM bytecode → x86_64 machine code translator
├── arch/                 Native code generation
│   ├── x86_64/           x86_64 encoder + lowering (53 privileged instructions)
│   ├── arm64/            ARM64 encoder + lowering (68/68 examples)
│   ├── ir/               Intermediate representation, register allocator
│   ├── link/             Internal linker (symbol resolution + relocation)
│   └── formats/          Object file emitters: PE32+, ELF64, Mach-O
├── compat/               Linux compatibility layer
│   ├── syscall/          ~450 x86_64 Linux syscalls mapped to BEAM messages
│   ├── elf/              ELF64 relocatable object loader (.ko modules)
│   └── kpi/              66 Linux Kernel Programming Interface shims
├── tests/                All tests (separated from source)
│   ├── kernel/           Kernel module tests (*_test.erl)
│   ├── vm/               VM module tests
│   ├── native/           V test programs for native compilation
│   └── data/             Test data files
├── tools/                Build scripts, QEMU helpers, test runners
├── docs/                 Architecture docs, boot sequence, syscall tables
├── meta/                 Hackathon submission materials
├── assets/               Images and font previews
└── thoughts/             Architecture sketches and design notes
```

## The Pipeline

```
V Source (.v)
     |
     v
V-on-BEAM Compiler (vbeam — separate repo)
     |
     +---> BEAM bytecode (.beam)  ---> BEAM VM ---> output
     |
     +---> Native x86_64 binary   ---> bare metal ---> output
```

## Boot from Nothing

Loom OS boots on real UEFI hardware:

```
UEFI firmware
  -> nucleus.efi (5KB PE32+ binary, generated by Erlang)
    -> Serial console init (COM1, 115200 baud)
    -> GOP framebuffer init (800x600x32bpp)
    -> Boot splash: loom grid + "LOOM OS v0.2.0"
    -> V native code executes: "Hello from V on BEAM!"
```

The entire boot binary is generated byte-by-byte by Erlang. No assembler, no linker, no external toolchain.

## Fault Tolerance (The Killer Feature)

```
Linux:     Driver crashes -> kernel panic -> reboot -> minutes of downtime
Loom OS:   Driver crashes -> supervisor restarts it -> <1ms -> users never notice
```

Every component is a supervised process:
```
                loom_root_sup
               /      |       \
          hal_sup   beam_sup   app_sup
         /  |  \      |  \      |  \
      serial fb timer code proc vfs net
```

## Hot Code Reload

Update a running driver without stopping the system. Same PID. Same state. New code. No restart.

## Component Status

| Component | Status | Location |
|-----------|--------|----------|
| UEFI boot nucleus | 5KB .efi, boots in QEMU | `boot/` |
| Boot splash | GOP framebuffer, VGA fonts, loom grid | `boot/` |
| BEAM interpreter | 30+ opcodes, runs V hello world | `vm/interp/` |
| Standalone parser | No OTP deps, bare-metal ready | `vm/parser/` |
| BEAM-to-native JIT | BEAM bytecode -> x86_64 machine code | `vm/jit/` |
| Kernel: boot sequence | GDT→IDT→paging→stack→kernel | `kernel/boot/` |
| Kernel: memory mgmt | Page allocator, paging, heap | `kernel/mm/` |
| Kernel: scheduler | Preemptive, priority-based | `kernel/sched/` |
| Kernel: I/O + IRQ | Serial, framebuffer, interrupt bridge | `kernel/io/` |
| Linux syscall layer | ~450 syscalls mapped | `compat/syscall/` |
| ELF .ko loader | Full ELF64 parsing, x86_64 relocations | `compat/elf/` |
| LinuxKPI shims | 66 Linux kernel API stubs | `compat/kpi/` |
| Native x86_64 | 53 privileged instructions | `arch/x86_64/` |
| Native ARM64 | 68/68 examples compile | `arch/arm64/` |
| IR + regalloc | Full pipeline, data type IR | `arch/ir/` |
| PE/ELF/Mach-O | All three object formats | `arch/formats/` |

## Build & Run

```bash
# Prerequisites: Erlang/OTP 26+

# Show all available targets
make help

# Build everything
make all

# Build the UEFI nucleus
make nucleus

# Test in QEMU (requires qemu-system-x86_64 + OVMF)
make qemu-test

# Run all tests
make test

# Compile specific subsystems
make boot-compile
make kernel-compile
make vm-compile
make arch-compile
make compat-compile

# Project info (module counts, build status)
make info

# Syntax checking
make check
```

## Relationship to vbeam

Loom OS was developed within the [vbeam](https://github.com/ylluminate/vbeam) project and has been separated into its own repository for clarity. The V-to-BEAM compiler lives in vbeam; the OS kernel and native backends live here.

## Built with Claude Opus 4.6

This entire system was designed and implemented in collaboration with Claude Opus 4.6, which:

- Wrote x86_64 machine code byte-by-byte for the UEFI bootloader
- Implemented a BEAM bytecode interpreter from scratch
- Designed the QNX-like supervisor tree architecture
- Fixed PE32+ emitter bugs by understanding the PE spec
- Generated VGA bitmap font rendering in raw machine code
- Parallelized implementation across 7+ simultaneous Sonnet workers
- Maintained project continuity across 30+ sessions via structured handoff documents

## License

Open source. MIT.
